#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
描述
从非负整数序列 0, 1, 2, ..., n中给出包含其中n个数的子序列，请找出未出现在该子序列中的那个数。
输入描述：
输入为n + 1个非负整数，用空格分开。
其中：首个数字为非负整数序列的最大值n，后面n个数字为子序列中包含的数字。
输出描述：
输出为1个数字，即未出现在子序列中的那个数。
int main()//大神算法
{
	int a;
	int b[10000];
	int i = 0, j = 0;
	scanf("%d", &a);
	for (i = 0;i < a;i++)
		scanf("%d", &b[i]);
	int min, temp;
	for (i = 0;i < a;i++)
	{
		min = b[i];
		for (j = i + 1;j < a;j++)
			if (b[j] < min)
			{
				temp = b[j];
				b[j] = min;
				min = temp;
			}
		b[i] = min;
	}
	for (i = 0;i < a;i++)
		if (b[i] != i)
		{
			printf("%d", i);break;
		}
}
int main()//简单算法
{
	int a;
	int b[1000];
	int i = 0, num = 0;
	scanf("%d", &a);
	for (i = 0;i < a;i++)
		scanf("%d", &b[i]);
	int sum1 = a * (a + 1) / 2, sum2 = 0;
	for (i = 0;i < a;i++)
		sum2 += b[i];
	num = sum1 - sum2;
	printf("%d", num);
	return 0;
}

描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
数据范围：1≤n≤40
/**
 *
 * @param number int整型
 * @return int整型
 */
int jumpFloor(int number){
	// write code here
	int a = 1;//n-2阶跳法
	int b = 1;//n-1阶跳法
	int c = 0;//n阶
	if (number == 0 || number == 1) {
		return number;
	}
	for (int i = 2;i <= number;i++) {
		c = b + a;
		a = b;
		b = c;
	}
	return c;
}

描述
给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。
例如，给出n = 3，解集为：
"((()))", "(()())", "(())()", "()()()", "()(())"
数据范围：100≤n≤10
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 *
 * @param n int整型
 * @return string字符串一维数组
 * @return int* returnSize 返回数组行数
 *
 * C语言声明定义全局变量请加上static，防止重复定义
 */
void generate(int n, int left, int right, int high, char *cache, int **ret, int* returnSize)
{
	if ((left + right) == 2 * n) {
		memcpy(ret[*returnSize], cache, (2 * n) * sizeof(char));
		ret[*returnSize][2 * n] = '\0';
		(*returnSize) += 1;
		return;
	}
	/* 左括号数量如果不够， 可以继续添加左括号 */
	if (left < n) {
		cache[high] = '(';
		generate(n, left + 1, right, high + 1, cache, ret, returnSize);
	}
	/* 右括号要小于左括号数量 */
	if (right < left) {
		cache[high] = ')';
		generate(n, left, right + 1, high + 1, cache, ret, returnSize);
	}
}
char** generateParenthesis(int n, int* returnSize) {
	 write code here
	int **ret = malloc(1000 * sizeof(char *));

	for (int i = 0; i < 1000; i++) {
		ret[i] = malloc((2 * n + 1) * sizeof(char));
	}
	*returnSize = 0;
	char cache[2 * n + 1];
	generate(n, 0, 0, 0, cache, ret, returnSize);

	return ret;
}

描述
以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。
数据范围：len(s),len(t)≤100000，字符串仅由'0'~'9'构成
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 计算两个数之和
 * @param s string字符串 表示第一个整数
 * @param t string字符串 表示第二个整数
 * @return string字符串
 */
char* solve(char* s, char* t) {
	// write code here
	int lens = strlen(s);
	int lent = strlen(t);
	int lenresult = (lens > lent ? lens : lent) + 2;
	int curresult = lenresult - 1;
	int temp, flag = 0;
	char* result = (char*)malloc(sizeof(char) * (lenresult));
	result[curresult] = 0;
	while (lens || lent) {
		temp = flag;
		if (lent) temp += t[--lent] - '0';
		if (lens) temp += s[--lens] - '0';
		flag = temp / 10;
		temp %= 10;
		result[--curresult] = temp + '0';
	}
	result[0] = flag + '0';
	return flag ? result : result + 1;
}
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 计算两个数之和
 * @param s string字符串 表示第一个整数
 * @param t string字符串 表示第二个整数
 * @return string字符串
 *
 * C语言声明定义全局变量请加上static，防止重复定义
 */
char* solve(char* s, char* t) //大神算法
{
	// write code here
	int sLen = strlen(s);
	int tLen = strlen(t);
	int resultLen;

	if (sLen == 0)
		return t;
	if (tLen == 0)
		return s;
	//2个数字相加，和的位数最多为较长数字位数+1，因为是字符串，预留一个'\0'的位置，所有+2
	if (sLen > tLen)
		resultLen = sLen + 2;
	else
		resultLen = tLen + 2;

	//char *result = (char *)malloc(sizeof(char)*resultLen);
	char *result = (char *)calloc(resultLen, sizeof(char));
	int sPos = sLen - 1;//求和从最后一位开始
	int tPos = tLen - 1;
	int resPos = 0;//记录和的字符串当前位置
	int carry = 0;//进位
	int sum = 0;//求和
	int i, j;//翻转字符串

	while (sPos >= 0 || tPos >= 0 || carry > 0)
	{
		//从后往前，取每位的数字,若较长数字位有效，但较短数字位无效，则较短数字位返回0
		int n1 = sPos >= 0 ? s[sPos--] - '0' : 0;
		int n2 = tPos >= 0 ? t[tPos--] - '0' : 0;
		sum = n1 + n2 + carry;
		if (sum >= 10)
		{
			carry = 1;
			result[resPos++] = sum % 10 + '0';
		}
		else
		{
			carry = 0;
			result[resPos++] = sum + '0';
		}
	}

	//s=1,t=99时，result=001，需原地翻转字符串为100
	for (i = 0, j = resPos - 1; i < j; i++, j--)
	{
		char tmp = result[i];
		result[i] = result[j];
		result[j] = tmp;
	}
	return result;
}
描述
给定一个无序数组，包含正数、负数和0，要求从中找出3个数的乘积，使得乘积最大，要求时间复杂度：O(n)，空间复杂度：O(1)
输入描述：
输入共2行，第一行包括一个整数n，表示数组长度 第二行为n个以空格隔开的整数，分别为A1, A2, …, An
输出描述：
满足条件的最大乘积
/*C语言 找到最大的三个正数，最小的两个负数*/
int main()
{
	int length, i;
	scanf("%d", &length);
	long min1 = 1, min2 = 1;
	long max1 = 1, max2 = 1, max3 = 1;
	long value, max_product = -1;
	for (i = 0;i < length;i++)
	{
		scanf("%ld", &value);
		if (value > max1) { max3 = max2;max2 = max1;max1 = value; }
		else if (value > max2) { max3 = max2;max2 = value; }
		else if (value > max3)max3 = value;
		else if (value < min1) { min2 = min1;min1 = value; }
		else if (value < min2)min2 = value;
	}
	if (max2 + max3 > -min1 - min2)max_product = max1 * max2*max3;    else max_product = min1 * min2*max1;
	printf("%ld\n", max_product);
	return 0;
}

描述
小招喵喜欢在数轴上跑来跑去，假设它现在站在点n处，它只会3种走法，分别是：
1.数轴上向前走一步，即n = n + 1
2.数轴上向后走一步, 即n = n - 1
3.数轴上使劲跳跃到当前点的两倍，即n = 2 * n
现在小招喵在原点，即n = 0，它想去点x处，快帮小招喵算算最快的走法需要多少步？
输入描述：
小招喵想去的位置x
输出描述：
小招喵最少需要的步数
