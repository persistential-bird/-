#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
描述
从非负整数序列 0, 1, 2, ..., n中给出包含其中n个数的子序列，请找出未出现在该子序列中的那个数。
输入描述：
输入为n + 1个非负整数，用空格分开。
其中：首个数字为非负整数序列的最大值n，后面n个数字为子序列中包含的数字。
输出描述：
输出为1个数字，即未出现在子序列中的那个数。
int main()//大神算法
{
	int a;
	int b[10000];
	int i = 0, j = 0;
	scanf("%d", &a);
	for (i = 0;i < a;i++)
		scanf("%d", &b[i]);
	int min, temp;
	for (i = 0;i < a;i++)
	{
		min = b[i];
		for (j = i + 1;j < a;j++)
			if (b[j] < min)
			{
				temp = b[j];
				b[j] = min;
				min = temp;
			}
		b[i] = min;
	}
	for (i = 0;i < a;i++)
		if (b[i] != i)
		{
			printf("%d", i);break;
		}
}
int main()//简单算法
{
	int a;
	int b[1000];
	int i = 0, num = 0;
	scanf("%d", &a);
	for (i = 0;i < a;i++)
		scanf("%d", &b[i]);
	int sum1 = a * (a + 1) / 2, sum2 = 0;
	for (i = 0;i < a;i++)
		sum2 += b[i];
	num = sum1 - sum2;
	printf("%d", num);
	return 0;
}

描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
数据范围：1≤n≤40
/**
 *
 * @param number int整型
 * @return int整型
 */
int jumpFloor(int number){
	// write code here
	int a = 1;//n-2阶跳法
	int b = 1;//n-1阶跳法
	int c = 0;//n阶
	if (number == 0 || number == 1) {
		return number;
	}
	for (int i = 2;i <= number;i++) {
		c = b + a;
		a = b;
		b = c;
	}
	return c;
}

描述
给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。
例如，给出n = 3，解集为：
"((()))", "(()())", "(())()", "()()()", "()(())"
数据范围：100≤n≤10
 
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 *
 * @param n int整型
 * @return string字符串一维数组
 * @return int* returnSize 返回数组行数
 *
 * C语言声明定义全局变量请加上static，防止重复定义
 */
void generate(int n, int left, int right, int high, char *cache, int **ret, int* returnSize)
{
	if ((left + right) == 2 * n) {
		memcpy(ret[*returnSize], cache, (2 * n) * sizeof(char));
		ret[*returnSize][2 * n] = '\0';
		(*returnSize) += 1;
		return;
	}
	/* 左括号数量如果不够， 可以继续添加左括号 */
	if (left < n) {
		cache[high] = '(';
		generate(n, left + 1, right, high + 1, cache, ret, returnSize);
	}
	/* 右括号要小于左括号数量 */
	if (right < left) {
		cache[high] = ')';
		generate(n, left, right + 1, high + 1, cache, ret, returnSize);
	}
}
char** generateParenthesis(int n, int* returnSize) {
	 write code here
	int **ret = malloc(1000 * sizeof(char *));

	for (int i = 0; i < 1000; i++) {
		ret[i] = malloc((2 * n + 1) * sizeof(char));
	}
	*returnSize = 0;
	char cache[2 * n + 1];
	generate(n, 0, 0, 0, cache, ret, returnSize);

	return ret;
}
描述
以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。
数据范围：len(s),len(t)≤100000，字符串仅由'0'~'9'构成
