结构体的自引用
struct Node
{
	int data;// 4
	struct Node* next;//4/8
};

typedef struct Node//结构体匿名使用，不可省略typedef struct Node中Node后直接struct调用
{
	double d;
	int data;//4
	struct Node* next;// 4/8
}Node;
int main()
{
	struct Node n1;
	Node n2;
	return 0;
}

struct S3
{
	char c;
	int i;
};
struct S4
{
	char c;
	struct S3 s3;
	double d;
};
int main()//结构体内存对齐
{
	//structS1 s1 = { 0 };
	//prin("%d\n",sizeof(s1));
	//struct S2 s2={ 0 };
	// printf("%d\n"，sizeof(s2);
	struct S3 s3;
	printf("%d\n", sizeof(s3));//8
	struct S4 s4;
	printf("%d\n", sizeof(s4));//24
	return 0;
}

为什么存在内存对齐?
大部分的参考资料都是如是说的;
1.平台原因(移植原因):不是所有的硬件平台都能访问任意地址上的任意数据的;某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
⒉性能原因:数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问;而对齐的内存访问仅需要一次访问。
总体来说:
结构体的内存对齐是拿空间来换取时间的做法。

//设量默认对齐数位4
#pragma pack(4)
struct S
{
	char c1;//1 
	// 7
	double d;//8
};
#pragma pack()
//取消设宣的默认对齐数
int main()
{
	struct S s;
	printf("%d\n", sizeof(s));//12
	return 0;
}

#include <stddef.h>
struct s
{
	char c;
	int i;
	double d;
};
int main()//计算成员相对于结构体的偏移量
{
	// offsetof();
	printf("%d\n", offsetof(struct s, c));//0
	printf("%d\n", offsetof(struct s, i));//4
	printf("%d\n", offsetof(struct s, d));//8
	return 0;
}

//位段-二进制位
struct S
{
	int a : 2;
	int b : 5;
	int c : 18;
	int d : 30;
};
// 47bit - 6个字节 * 8 = 48bit
int main()
{
	struct S s;
	printf("%d\n", sizeof(s)); //8个字节
	return 0;
}
